using System;
using System.ComponentModel;
using System.Security.Permissions;
using System.Windows.Forms;
using LanExchange.Controls.Implementation;

namespace LanExchange.Controls
{
    /// <summary>
    /// Extended version of ListView.
    /// </summary>
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Lan")]
    public class LanExchangeListView : ListView
    {
        /// <summary>
        /// Right click on ListView's column.
        /// </summary>
        public event EventHandler<ColumnClickEventArgs> ColumnRightClick;

        /// <summary>
        /// Constructor.
        /// </summary>
        public LanExchangeListView()
        {
            // switch off flikering only if not terminal session
            if (!SystemInformation.TerminalServerSession)
                SetStyle(ControlStyles.DoubleBuffer | ControlStyles.OptimizedDoubleBuffer, true);

            SelectAllEnabled = true;
        }

        /// <summary>
        /// Processing some messages in WndProc.
        /// </summary>
        /// <param name="m"></param>
        [SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.UnmanagedCode)]
        protected override void WndProc(ref Message m)
        {
            const int WM_CONTEXTMENU = 0x007B;

            switch (m.Msg)
            {
                case WM_CONTEXTMENU: 
                    if (!HandleContextMenu(ref m))
                        base.WndProc(ref m);
                    break;
                default:
                    base.WndProc(ref m);
                    break;
            }
        }

        /// <summary>
        /// The user wants to see the context menu.
        /// </summary>
        /// <param name="message">The windows m</param>
        /// <returns>A bool indicating if this m has been handled</returns>
        /// <remarks>
        /// We want to ignore context menu requests that are triggered by right clicks on the header
        /// </remarks>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1045:DoNotPassTypesByReference", MessageId = "0#")]
        protected virtual bool HandleContextMenu(ref Message message)
        {
            // Don't try to handle context menu commands at design time.
            if (DesignMode)
                return false;

            // If the context menu command was generated by the keyboard, LParam will be -1.
            // We don't want to process these.
            if (message.LParam == minusOne)
                return false;

            // If the context menu came from somewhere other than the header control,
            // we also don't want to ignore it
            if (message.WParam != Header.Handle)
                return false;

            int columnIndex = Header.ColumnIndexUnderCursor;
            return HandleHeaderRightClick(columnIndex);
        }
        readonly IntPtr minusOne = new IntPtr(-1);

        /// <summary>
        /// Gets the header control for the ListView
        /// </summary>
        [Browsable(false)]
        public LanExchangeHeader Header
        {
            get
            {
                return m_Header ?? (m_Header = new LanExchangeHeader(this));
            }
        }
        private LanExchangeHeader m_Header;


        /// <summary>
        /// The user has right clicked on the column headers. Do whatever is required
        /// </summary>
        /// <returns>Return true if this event has been handle</returns>
        protected virtual bool HandleHeaderRightClick(int columnIndex)
        {
            if (ColumnRightClick != null)
            {
                ColumnRightClick(this, new ColumnClickEventArgs(columnIndex));
                return true;
            }
            return false;
        }

        /// <summary>
        /// OnCreateControl override for initialization.
        /// </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1303:Do not pass literals as localized parameters", MessageId = "System.Windows.Forms.ToolTip.SetToolTip(System.Windows.Forms.Control,System.String)"), Localizable(false)]
        protected override void OnCreateControl()
        {
            m_ToolTip = new ToolTip(); 
            m_ToolTip.IsBalloon = true;
            m_ToolTip.ToolTipIcon = ToolTipIcon.Info;
            m_ToolTip.SetToolTip(this, " ");
            m_ToolTip.Popup += ToolTipOnPopup;
            m_ToolTip.Active = View != View.Details;

            UseExplorerTheme = UseExplorerTheme;
        }

        private void ToolTipOnPopup(object sender, PopupEventArgs e)
        {
            if (sender == m_ToolTip && e.AssociatedControl == this)
            {
                var point = PointToClient(MousePosition);
                var info = HitTest(point);
                if (info.Item != null)
                    m_ToolTip.ToolTipTitle = info.Item.Text;
            }
        }

        /// <summary>
        /// OnKeyDown override for Ctrl+A processing.
        /// </summary>
        /// <param name="e"></param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1062:Validate arguments of public methods", MessageId = "0")]
        protected override void OnKeyDown(KeyEventArgs e)
        {
            // Ctrl+A - Select all items
            if (SelectAllEnabled)
                if (e.Modifiers == Keys.Control && e.KeyCode == Keys.A)
                {
                    this.SelectAllItems();
                    e.Handled = true;
                }
            base.OnKeyDown(e);
        }

        /// <summary>
        /// Is balloon tooltip active?
        /// </summary>
        [Category("LanExchange")]
        [Description("Is balloon tooltip active?")]
        [DefaultValue(false)]
        public bool ToolTipActive
        {
            get { return m_ToolTip != null && m_ToolTip.Active; }
            set
            {
                if (m_ToolTip != null)
                    m_ToolTip.Active = value;
            }
        }

        private ToolTip m_ToolTip;

        /// <summary>
        /// Gets or sets whether this LanExchangeListView will use the same hot item and selection 
        /// mechanism that Vista Explorer does.
        /// </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1806:DoNotIgnoreMethodResults", MessageId = "LanExchange.Controls.Implementation.NativeMethods.SetWindowTheme(System.IntPtr,System.String,System.String)")]
        [Category("LanExchange")]
        [Description("Should the list use the same hot item and selection mechanism as Vista?")]
        [DefaultValue(false)]
        public bool UseExplorerTheme
        {
            get { return m_UseExplorerTheme; }
            set
            {
                m_UseExplorerTheme = value;
                if (Created)
                    NativeMethods.SetWindowTheme(Handle, value ? "explorer" : "", null);
            }
        }
        
        private bool m_UseExplorerTheme;

        /// <summary>
        /// Gets or sets whether ListView will select all item on Ctrl+A shortcut.
        /// </summary>
        [Category("LanExchange")]
        [Description("Process Ctrl+A shortcut for selecting all items.")]
        [DefaultValue(true)]
        public bool SelectAllEnabled { get; set; }

    }
}